{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "6a70c685",
   "metadata": {},
   "source": [
    "# import part"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "8ba111d9",
   "metadata": {},
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "import matplotlib.pyplot as plt\n",
    "from matplotlib import cm\n",
    "from sklearn import neighbors, model_selection\n",
    "import seaborn as sns\n",
    "from matplotlib.colors import ListedColormap "
   ]
  },
  {
   "cell_type": "markdown",
   "id": "66cce5e4",
   "metadata": {},
   "source": [
    "# Data generation"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "15149ac5",
   "metadata": {},
   "outputs": [],
   "source": [
    "def rand_gauss(n=100, mu=[1, 1], sigma=[0.1, 0.1]):\n",
    "    \"\"\" Sample n points from a Gaussian variable with center mu,\n",
    "    and std deviation sigma\n",
    "    \"\"\"\n",
    "    d = len(mu)\n",
    "    res = np.random.randn(n, d)\n",
    "    return np.array(res * sigma + mu)\n",
    "\n",
    "def rand_bi_gauss(n1=100, n2=100, mu1=[1, 1], mu2=[-1, -1], sigmas1=[0.1, 0.1], sigmas2=[0.1, 0.1]):\n",
    "    \"\"\"Sample n1 and n2 points from two Gaussian distributions with centers mu1 and mu2, and standard deviations sigmas1 and sigmas2.\"\"\"\n",
    "    X = np.vstack([rand_gauss(n1, mu1, sigmas1), rand_gauss(n2, mu2, sigmas2)])\n",
    "    y = np.hstack([np.ones(n1), -np.ones(n2)])\n",
    "    ind = np.random.permutation(n1 + n2)\n",
    "    return X[ind, :], y[ind]\n",
    "\n",
    "def rand_tri_gauss(n1=100, n2=100, n3=100, mu1=[1, 1], mu2=[-1, -1], mu3=[1, -1], sigma1=[0.1, 0.1], sigma2=[0.1, 0.1], sigma3=[0.1, 0.1]):\n",
    "    \"\"\"Sample n1, n2, and n3 points from three Gaussian distributions centered at mu1, mu2, and mu3 with standard deviations sigma1, sigma2, and sigma3.\"\"\"\n",
    "    X = np.vstack([rand_gauss(n1, mu1, sigma1), rand_gauss(n2, mu2, sigma2), rand_gauss(n3, mu3, sigma3)])\n",
    "    y = np.hstack([np.ones(n1), 2 * np.ones(n2), 3 * np.ones(n3)])\n",
    "    ind = np.random.permutation(n1 + n2 + n3)\n",
    "    return X[ind, :], y[ind]\n",
    "\n",
    "def rand_clown(n1=100, n2=100, sigma1=1, sigma2=2):\n",
    "    \"\"\" Sample a dataset clown  with\n",
    "    n1 points and noise std deviation sigma1 for the first class, and\n",
    "    n2 points and noise std deviation sigma2 for the second one\n",
    "    \"\"\"\n",
    "    x0 = np.random.randn(n1, 1)\n",
    "    x1 = x0 * x0 + sigma1 * np.random.randn(n1, 1)\n",
    "    x2 = np.hstack([sigma2 * np.random.randn(n2, 1),\n",
    "                    sigma2 * np.random.randn(n2, 1) + 2.])\n",
    "    X = np.vstack([np.hstack([x0, x1]), x2])\n",
    "    y = np.hstack([np.ones(n1), -1 * np.ones(n2)])\n",
    "    ind = np.random.permutation(n1 + n2)\n",
    "    return X[ind, :], y[ind] \n",
    "\n",
    "def rand_checkers(n1=100, n2=100, sigma=0.1):\n",
    "    \"\"\"Sample n1 and n2 points from a noisy checkerboard pattern.\"\"\"\n",
    "    nbp = int(n1 / 8)\n",
    "    nbn = int(n2 / 8)\n",
    "    xapp = np.reshape(np.random.rand((nbp + nbn) * 16), [(nbp + nbn) * 8, 2])\n",
    "    yapp = np.ones((nbp + nbn) * 8)\n",
    "    idx = 0\n",
    "    for i in range(-2, 2):\n",
    "        for j in range(-2, 2):\n",
    "            nb = nbp if (i + j) % 2 == 0 else nbn\n",
    "            yapp[idx:idx + nb] = ((i + j) % 3 + 1) * np.ones(nb)\n",
    "            xapp[idx:idx + nb, 0] += i + sigma * np.random.randn(nb)\n",
    "            xapp[idx:idx + nb, 1] += j + sigma * np.random.randn(nb)\n",
    "            idx += nb\n",
    "    ind = np.random.permutation((nbp + nbn) * 8)\n",
    "    res = np.hstack([xapp, yapp[:, np.newaxis]])\n",
    "    return res[ind, :2], res[ind, 2]"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "6a3768a4",
   "metadata": {},
   "source": [
    "# Displaying labeled data"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "55f9e900",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Liste des symboles utilisés pour le tracé des points\n",
    "symlist = ['o', 's', 'D', 'x', '+', '*', 'p', 'v', '-', '^']\n",
    "\n",
    "def plot_2d(ax, data, y=None, alpha_choice=1):\n",
    "    k = np.max([np.unique(y).shape[0], 1])\n",
    "    color_blind_list = sns.color_palette(\"colorblind\", k)\n",
    "    sns.set_palette(color_blind_list)\n",
    "    if y is None:\n",
    "        ax.scatter(data[:, 0], data[:, 1], s=80, marker=symlist[0])\n",
    "    else:\n",
    "        labs = np.unique(y)\n",
    "        idxbyclass = [np.where(y == lab)[0] for lab in labs]\n",
    "        for i, idx in enumerate(idxbyclass):\n",
    "            ax.scatter(data[idx, 0], data[idx, 1], c=np.reshape(color_blind_list[i], (1, -1)), s=80, marker=symlist[i % len(symlist)], label=f\"Class {int(labs[i])}\")\n",
    "    ax.set_ylim([np.min(data[:, 1]) - 1, np.max(data[:, 1]) + 1])\n",
    "    ax.set_xlim([np.min(data[:, 0]) - 1, np.max(data[:, 0]) + 1])\n",
    "    if y is not None:\n",
    "        ax.legend()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "c15a47c7",
   "metadata": {},
   "source": [
    "# Displaying tools for frontiere"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "5d687af6",
   "metadata": {},
   "outputs": [],
   "source": [
    " def frontiere(f, data, step=50, cmap_choice=cm.coolwarm, tiny=False):\n",
    "    \"\"\" trace la frontiere pour la fonction de decision f\"\"\"\n",
    "    xmin, xmax = data[:, 0].min() - 1., data[:, 0].max() + 1.\n",
    "    ymin, ymax = data[:, 1].min() - 1., data[:, 1].max() + 1.\n",
    "    xx, yy = np.meshgrid(np.arange(xmin, xmax, (xmax - xmin) * 1. / step),\n",
    "                         np.arange(ymin, ymax, (ymax - ymin) * 1. / step))\n",
    "    z = f(np.c_[xx.ravel(), yy.ravel()])\n",
    "    z = z.reshape(xx.shape)\n",
    "    plt.imshow(z, origin='lower', interpolation=\"nearest\",\n",
    "               extent=[xmin, xmax, ymin, ymax], cmap=cmap_choice)\n",
    "    if tiny:\n",
    "        plt.xticks([])\n",
    "        plt.yticks([])\n",
    "    else:\n",
    "        plt.colorbar() \n",
    "        \n",
    "def frontiere_new(f, X, y, w=None, step=50, alpha_choice=1, colorbar=True, samples=True):\n",
    "    \"\"\"Trace la frontière pour la fonction de décision f.\"\"\"\n",
    "    \n",
    "    min_tot0, min_tot1 = np.min(X[:, 0]), np.min(X[:, 1])\n",
    "    max_tot0, max_tot1 = np.max(X[:, 0]), np.max(X[:, 1])\n",
    "    \n",
    "    delta0 = (max_tot0 - min_tot0)\n",
    "    delta1 = (max_tot1 - min_tot1)\n",
    "    \n",
    "    xx, yy = np.meshgrid(np.arange(min_tot0, max_tot0, delta0 / step),\n",
    "                         np.arange(min_tot1, max_tot1, delta1 / step))\n",
    "    \n",
    "    z = np.array([f(vec) for vec in np.c_[xx.ravel(), yy.ravel()]])\n",
    "    z = z.reshape(xx.shape)\n",
    "    \n",
    "    labels = np.unique(z)\n",
    "    color_blind_list = sns.color_palette(\"colorblind\", labels.shape[0])\n",
    "    sns.set_palette(color_blind_list)\n",
    "    \n",
    "    my_cmap = ListedColormap(color_blind_list)\n",
    "    \n",
    "    plt.imshow(z, origin='lower', interpolation=\"mitchell\", alpha=0.80,\n",
    "               cmap=my_cmap, extent=[min_tot0, max_tot0, min_tot1, max_tot1])\n",
    "    \n",
    "    if colorbar:\n",
    "        ax = plt.gca()\n",
    "        cbar = plt.colorbar(ticks=labels)\n",
    "        cbar.ax.set_yticklabels(labels)\n",
    "    \n",
    "    labels = np.unique(y)\n",
    "    k = np.unique(y).shape[0]\n",
    "    color_blind_list = sns.color_palette(\"colorblind\", k)\n",
    "    sns.set_palette(color_blind_list)\n",
    "    ax = plt.gca()\n",
    "    \n",
    "    if samples:\n",
    "        for i, label in enumerate(y):\n",
    "            label_num = np.where(labels == label)[0][0]\n",
    "            plt.scatter(X[i, 0], X[i, 1],\n",
    "                        c=np.reshape(color_blind_list[label_num], (1, -1)),\n",
    "                        s=80, marker=symlist[label_num])\n",
    "    \n",
    "    plt.xlim([min_tot0, max_tot0])\n",
    "    plt.ylim([min_tot1, max_tot1])\n",
    "    ax.get_yaxis().set_ticks([])\n",
    "    ax.get_xaxis().set_ticks([])\n",
    "    \n",
    "    if w is not None:\n",
    "        plt.plot([min_tot0, max_tot0],\n",
    "                 [min_tot0 * -w[1] / w[2] - w[0] / w[2],\n",
    "                  max_tot0 * -w[1] / w[2] - w[0] / w[2]],\n",
    "                 \"k\", alpha=alpha_choice)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "156dd2b7",
   "metadata": {},
   "source": [
    "# Algorithms and function"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "9c235ec2",
   "metadata": {},
   "outputs": [],
   "source": [
    " class ErrorCurve(object):\n",
    "    def __init__(self, k_range=None, weights='uniform'):\n",
    "        if k_range is None:\n",
    "            k_range = list(range(1, 6))\n",
    "        self.k_range = k_range\n",
    "        self.weights = weights\n",
    "\n",
    "    def fit_curve(self, X, y, Xtest, ytest):\n",
    "        def error_func(k):\n",
    "            knn = neighbors.KNeighborsClassifier(n_neighbors=k,\n",
    "                                                 weights=self.weights)\n",
    "\n",
    "            knn.fit(X, y)\n",
    "            error = np.mean(knn.predict(Xtest) != ytest)\n",
    "            return error\n",
    "\n",
    "        errors = list(map(error_func, self.k_range))\n",
    "        self.errors = np.array(errors)\n",
    "        self.y = y\n",
    "\n",
    "    def plot(self, marker='o', maketitle=True, **kwargs):\n",
    "        plt.plot(self.k_range, self.errors, marker=marker, **kwargs)\n",
    "        plt.xlabel(\"K\")\n",
    "        plt.ylabel(\"Test error\")\n",
    "        if maketitle:\n",
    "            plt.title(\"number of training points : %d\" % len(self.y))\n",
    "            \n",
    "class LOOCurve(object):\n",
    "    \"\"\"Leave-One-Out (LOO) curve\"\"\"\n",
    "    def __init__(self, k_range=None, weights='uniform'):\n",
    "        if k_range is None:\n",
    "            k_range = list(range(1, 6))\n",
    "        self.k_range = k_range\n",
    "        self.weights = weights\n",
    "\n",
    "    def fit_curve(self, X, y, n_iter=200, random_state=1):\n",
    "        def score_func(k):\n",
    "            n_samples = len(X)\n",
    "\n",
    "\n",
    "            # Selon la verson de scikit-learn : shuffleSplit prend en argument\n",
    "\n",
    "\n",
    "            # 'niter ' ou niterations'. De plus, l'argument test_size peut ne\n",
    "\n",
    "\n",
    "            # pas etre reconnu. Il est recommande de consulter\n",
    "\n",
    "\n",
    "            # help(model_selection.ShuffleSplit) pour connaitre la liste\n",
    "\n",
    "\n",
    "            # des arguments reconnus par votre version de sickitlearn.\n",
    "            loo = model_selection.ShuffleSplit(n_iter,\n",
    "                                                test_size=1,\n",
    "                                                train_size=n_samples-1,\n",
    "                                                random_state=random_state)\n",
    "            knn = neighbors.KNeighborsClassifier(n_neighbors=k,\n",
    "                                                 weights=self.weights)\n",
    "            scores = model_selection.cross_val_score(estimator=knn,\n",
    "                                                      X=X, y=y,\n",
    "                                                      cv=loo)\n",
    "            return np.mean(scores)\n",
    "\n",
    "        scores = list(map(score_func, self.k_range))\n",
    "        self.cv_scores = np.array(scores)\n",
    "        self.y = y\n",
    "\n",
    "\n",
    "    def plot(self, marker='o', maketitle=True, **kwargs):\n",
    "        plt.plot(self.k_range, self.cv_scores, marker=marker, **kwargs)\n",
    "        plt.xlabel(\"K\")\n",
    "        plt.ylabel(\"Leave One Out Score (1-error rate)\")\n",
    "        if maketitle:\n",
    "            plt.title(\"number of training points : %d\" % (len(self.y) - 1))"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.11.5"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
